/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-SCARD.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : SCARD
 #	author : miyako
 #	2021/11/04
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-SCARD.h"

/*
 
 mutex protected global object to store status
 
 */

static std::mutex scardMutex;
static Json::Value scardStorage;
static std::map< std::string, std::future<void> >scardTasks;

#pragma mark -

static void scard_clear(std::string& uuid) {
    std::map< std::string, std::future<void> >::iterator it = scardTasks.find(uuid);
    if(it != scardTasks.end()) {
        scardStorage.removeMember(uuid);
        it->second.get();
        scardTasks.erase(it);
    }
}

static void scard_clear_all() {
    for( auto it = scardTasks.begin(); it != scardTasks.end() ; ++it ) {
        std::string uuid = it->first;
        scardStorage.removeMember(uuid);
        it->second.get();
    }
    scardTasks.clear();
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- SCARD
            
			case 1 :
				SCARD_Get_readers(params);
				break;
			case 2 :
				SCARD_Read_tag(params);
				break;
            case 3 :
                SCARD_Get_status(params);
                break;

            case kDeinitPlugin :
            case kServerDeinitPlugin :
                scard_clear_all();
                break;
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static void generateUuid(std::string &uuid) {
    
#if VERSIONWIN
    RPC_WSTR str;
    UUID uid;
    if (UuidCreate(&uid) == RPC_S_OK) {
        if (UuidToString(&uid, &str) == RPC_S_OK) {
            size_t len = wcslen((const wchar_t *)str);
            std::vector<wchar_t>buf(len+1);
            memcpy(&buf[0], str, len * sizeof(wchar_t));
            _wcsupr((wchar_t *)&buf[0]);
			CUTF16String wstr = CUTF16String((const PA_Unichar *)&buf[0], len);
            u16_to_u8(wstr, uuid);
            RpcStringFree(&str);
        }
    }
#else
    NSString *u = [[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""];
    uuid = [u UTF8String];
#endif
}

static void print_hex(const uint8_t *pbtData, const size_t szBytes, std::string &hex) {
    
    std::vector<uint8_t> buf((szBytes * 2) + 1);
    memset((char *)&buf[0], 0, buf.size());
    
    for (size_t i = 0; i < szBytes; ++i) {
        sprintf((char *)&buf[i * 2], "%02x", pbtData[i]);
    }
    
    hex = std::string((char *)&buf[0], (szBytes * 2));
}

#if VERSIONMAC
static bool get_usb_information(libusb_device_handle *dh, usb_device_info *devinfo) {
    
    memset(devinfo, 0, sizeof(usb_device_info));
    
    libusb_device *dev;
    struct libusb_config_descriptor *conf;
    const struct libusb_endpoint_descriptor *endp;
    const struct libusb_interface *intf;
    const struct libusb_interface_descriptor *intdesc;
    
    dev = libusb_get_device(dh);
    
    if(dev == NULL){
        std::cout << "device get error..." << std::endl;
        return false;
    }
    
    devinfo->dh = dh;
    devinfo->dev = dev;
    
    libusb_get_config_descriptor(dev, 0, &conf);
    
    for(int i = 0; i < (int)conf->bNumInterfaces; i++){
        intf = &conf->interface[i];
        for(int j = 0; j < intf->num_altsetting; j++){
            intdesc = &intf->altsetting[j];
            for(int k = 0; k < (int)intdesc->bNumEndpoints; k++){
                endp = &intdesc->endpoint[k];
                
                switch(endp->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) {
                    case LIBUSB_TRANSFER_TYPE_BULK:
                        //printf("bulk endpoint: %02x\n", endp->bEndpointAddress);
                        if((endp->bEndpointAddress & 0x80) == LIBUSB_ENDPOINT_IN){
                            devinfo->ep_in = endp->bEndpointAddress;
                        }
                        if((endp->bEndpointAddress & 0x80) == LIBUSB_ENDPOINT_OUT){
                            devinfo->ep_out = endp->bEndpointAddress;
                        }
                        break;
                    case LIBUSB_TRANSFER_TYPE_INTERRUPT:
                        //printf("interrupt endpoint: %02x\n", endp->bEndpointAddress);
                        break;
                }
            }
        }
    }
    libusb_free_config_descriptor(conf);
    
    return true;
}

static int packet_init(usb_device_info *devinfo, int timeout) {
    
  uint8_t cmd[6];
  int ret;
  int len;

  // ack command
  memcpy(cmd, "\x00\x00\xff\x00\xff\x00", 6);
      
  ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_out,
                 (unsigned char *)cmd, sizeof(cmd), &len, timeout);
    
  if(ret < 0) std::cout << "data send error..." << std::endl;
    
  return ret;
}

static int packet_init_data(usb_device_info *devinfo, int timeout) {
    
  uint8_t cmd[2];
  int ret;
  int len;

  // data command
  memcpy(cmd, "\xff\xff", 2);
      
  ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_out,
                 (unsigned char *)cmd, sizeof(cmd), &len, timeout);
    
  if(ret < 0) std::cout << "data send error..." << std::endl;
    
  return ret;
}

static size_t packet_send(usb_device_info *devinfo, uint8_t *buf, int size,
                          std::vector<uint8_t> *usbbuf, int timeout) {
    
    uint8_t rcv[LIBUSB_DATASIZE], rbuf[LIBUSB_DATASIZE];
    
    int len;
    int ret;
    
    ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_out,
                               (unsigned char *)buf, size, &len, timeout);
    if(ret < 0){
        std::cout << "data send error..." << std::endl;
        return 0;
    }
    
    // receive ack/nck
    ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_in,
                               (unsigned char *)rcv, sizeof(rcv), &len, timeout);
    if(ret < 0){
        std::cout << "data receive error..." << std::endl;
        return 0;
    }
    
    len = 0;
    
    // receive response
    ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_in,
                               (unsigned char *)rbuf, sizeof(rbuf), &len, timeout);
    if(ret < 0){
        std::cout << "data receive error..." << std::endl;
        return 0;
    }
    
    if(len > usbbuf->size()) {
        usbbuf->resize(len);
    }
    
    memcpy(&usbbuf->at(0), rbuf, len);

    return len;
}

static size_t packet_write(usb_device_info *devinfo, uint8_t *buf, int size,
                             std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[LIBUSB_DATASIZE];
  int n;
  short csum;

  n = size;
  if(n < 1) return 0;

  // data = 0xd6 + data
  // len = len(data)
  // 00 00 ff ff ff len(L) len(H) checksum(len) data checksum(data) 00
    
    /* header */
    cmd[0] = 0x00; cmd[1] = 0x00; cmd[2] = 0xff;
    cmd[3] = 0xff; cmd[4] = 0xff;
    
    /* data length */
    cmd[5] = ((n + 1) & 0xff);
    cmd[6] = ((n + 1) & 0xff00) >> 8;
    
    /* checksum */
    csum = (0x100 - (cmd[5] + cmd[6])) % 0x100;
    cmd[7] = csum;
    
    /* delimiter */
    cmd[8] = 0xd6;
    
    /* data */
    memcpy(cmd + 9, buf, size);

    /* checksum */
    csum = checksum(cmd[8], buf, size);
    cmd[9 + n] = csum;
    
    /* terminator */
    cmd[10 + n] = 0x00;
    n += 11;
  
  return packet_send(devinfo, cmd, n, usbbuf, timeout);
}

static size_t packet_setcommandtype(usb_device_info *devinfo,
                                      std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[2];
  memcpy(cmd, "\x2a\x01", 2);
  return packet_write(devinfo, cmd, sizeof(cmd), usbbuf, timeout);
}

static size_t packet_switch_rf(usb_device_info *devinfo,
                                 std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[2];
  memcpy(cmd, "\x06\x00", 2);
    
  return packet_write(devinfo, cmd, sizeof(cmd), usbbuf, timeout);
}

static size_t packet_sens_req(usb_device_info *devinfo, char type,
                                std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[9];
  int len;
  if(type == 'F'){
    len = 9;
    memcpy(cmd, "\x04\x6e\x00\x06\x00\xff\xff\x01\x00", len);
  }
  if(type == 'A'){
    len = 4;
    memcpy(cmd, "\x04\x6e\x00\x26", len);
  }
  if(type == 'B'){
    len = 6;
    memcpy(cmd, "\x04\x6e\x00\x05\x00\x10", len);
  }
  return packet_write(devinfo, cmd, len, usbbuf, timeout);
}

static size_t packet_inset_rf(usb_device_info *devinfo, char type,
                                std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[5];
    
  if(type == 'F') memcpy(cmd, "\x00\x01\x01\x0f\x01", 5); // 212F
  if(type == 'A') memcpy(cmd, "\x00\x02\x03\x0f\x03", 5); // 106A
  if(type == 'B') memcpy(cmd, "\x00\x03\x07\x0f\x07", 5); // 106B
    
  return packet_write(devinfo, cmd, sizeof(cmd), usbbuf, timeout);
}

static size_t packet_inset_protocol_1(usb_device_info *devinfo,
                                      std::vector<uint8_t> *usbbuf, int timeout) {
    
    uint8_t cmd[39];
    
    memcpy(cmd, "\x02\x00\x18\x01\x01\x02\x01\x03\x00\x04\x00\x05\x00\x06\x00\x07\x08\x08\x00\x09\x00\x0a\x00\x0b\x00\x0c\x00\x0e\x04\x0f\x00\x10\x00\x11\x00\x12\x00\x13\x06", 39);
    
    return packet_write(devinfo, cmd, sizeof(cmd), usbbuf, timeout);
}

static size_t packet_inset_protocol_2(usb_device_info *devinfo, char type,
                                      std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[11];
    
  int len;
  if(type == 'F'){
    len = 3;
    memcpy(cmd, "\x02\x00\x18", len);
  }
  if(type == 'A'){
    len = 11;
    memcpy(cmd, "\x02\x00\x06\x01\x00\x02\x00\x05\x01\x07\x07", len);
  }
  if(type == 'B'){
    len = 11;
    memcpy(cmd, "\x02\x00\x14\x09\x01\x0a\x01\x0b\x01\x0c\x01", len);
  }
    
  return packet_write(devinfo, cmd, len, usbbuf, timeout);
}
#endif

#pragma mark -

static void SCARD_Get_readers(PA_PluginParameters params) {
    
	PA_ObjectRef options = PA_GetObjectParameter(params, 1);

    PA_ObjectRef status = PA_CreateObject();
    PA_CollectionRef readers = PA_CreateCollection();
    
#if VERSIONMAC
    
    if(!checkAccess(status)) {
        ob_set_s(status, L"warning", "com.apple.security.smartcard is missing in app entitlement");
    }
    
    std::string errorMessage;
    bool success = false;
    
    TKSmartCardSlotManager *manager = [TKSmartCardSlotManager defaultManager];
    
    if(manager) {
        NSArray<NSString *> *slotNames = [manager slotNames];
        for (NSString *slotName in slotNames) {
            PA_ObjectRef o = PA_CreateObject();
            ob_set_s(o, L"slotName", (const char *)[slotName UTF8String]);
            PA_Variable v = PA_CreateVariable(eVK_Object);
            PA_SetObjectVariable(&v, o);
            PA_SetCollectionElement(readers, PA_GetCollectionLength(readers), v);
        }
        success = true;
    }else{
        errorMessage = "TKSmartCardSlotManager::defaultManager() failed";
    }
#else
     /*
      
      windows
      
      */

	bool success = false;

	uint32_t scope = SCARD_SCOPE_USER;

	if (options) {
		if (ob_is_defined(options, L"scope")) {
			int _scope = ob_get_n(options, L"scope");
			switch (_scope) {
			case SCARD_SCOPE_USER:
			case SCARD_SCOPE_TERMINAL:
			case SCARD_SCOPE_SYSTEM:
				scope = _scope;
				break;
			default:
				break;
			}
		}
	}

	SCARDCONTEXT hContext;

	LONG lResult = SCardEstablishContext(scope, NULL, NULL, &hContext);

	/* http://eternalwindows.jp/security/scard/scard02.html */

	if (lResult == SCARD_E_NO_SERVICE) {
		HANDLE hEvent = SCardAccessStartedEvent();
		DWORD dwResult = WaitForSingleObject(hEvent, DEFAULT_TIMEOUT_MS_FOR_RESOURCE_MANAGER);
		if (dwResult == WAIT_OBJECT_0) {
			lResult = SCardEstablishContext(scope, NULL, NULL, &hContext);
		}
		SCardReleaseStartedEvent();
	}

	if (lResult == SCARD_S_SUCCESS) {

		DWORD len;
		lResult = SCardListReaders(hContext, SCARD_ALL_READERS, NULL, &len);
		if (lResult == SCARD_S_SUCCESS) {

			std::vector<TCHAR>buf(len);
			lResult = SCardListReaders(hContext, SCARD_ALL_READERS, &buf[0], &len);
			if (lResult == SCARD_S_SUCCESS) {

				LPTSTR pReader = (LPTSTR)&buf[0];
				if (pReader) {
					while ('\0' != *pReader) {

						PA_ObjectRef reader = PA_CreateObject();
						ob_set_a(reader, L"slotName", pReader);
						pReader = pReader + wcslen(pReader) + 1;

						PA_Variable v = PA_CreateVariable(eVK_Object);
						PA_SetObjectVariable(&v, reader);
						PA_SetCollectionElement(readers, PA_GetCollectionLength(readers), v);
						PA_ClearVariable(&v);
					}
					success = true;
				}

			}
		}
		SCardReleaseContext(hContext);
	}
#endif
    
#if VERSIONMAC
    int libusb_result = libusb_init(NULL);
    if(libusb_result >= 0) {
        libusb_device **devs;
        ssize_t count = libusb_get_device_list(NULL, &devs);
        if(count > 0) {
            for(int i = 0; i < count; ++i){
                libusb_device *dev = devs[i];
                libusb_device_descriptor desc;
                libusb_result = libusb_get_device_descriptor(dev, &desc);
                if(libusb_result >= 0) {
                    std::vector<uint8_t> buf(5);
                    memset ((char *)&buf[0], 0, buf.size());
                    sprintf((char *)&buf[0], "%04x", desc.idVendor);
                    std::string _vid = std::string((char *)&buf[0], 4);
                    memset ((char *)&buf[0], 0, buf.size());
                    sprintf((char *)&buf[0], "%04x", desc.idProduct);
                    std::string _pid = std::string((char *)&buf[0], 4);
                    
                    char *end;
                    int vid = (int)strtol(_vid.c_str(), &end, 16);
                    int pid = (int)strtol(_pid.c_str(), &end, 16);
                    int libusb_device_id = 0;
                    /*
                     Sony NFC Port-100 chipset.
                     The only product known to use this chipset is the PaSoRi RC-S380.
                     https://github.com/nfcpy/nfcpy/blob/master/src/nfc/clf/rcs380.py
                     */
                    
                    /*
                     Sony RC-S956 chipset.
                     Products known to use this chipset are the PaSoRi RC-S330, RC-S360, and RC-S370.
                     https://github.com/nfcpy/nfcpy/blob/master/src/nfc/clf/rcs956.py
                     */
                    if(vid == LIBUSB_SONY) {
                        switch (pid) {
                            case LIBUSB_SONY_RC_S380:
                            case LIBUSB_SONY_RC_S310:
                            case LIBUSB_SONY_RC_S320:
                            case LIBUSB_SONY_RC_S330:
                                libusb_device_id = pid;
                                break;
                            default:
                                break;
                        }
                        if(libusb_device_id != 0) {
                            PA_ObjectRef o = PA_CreateObject();
                            switch (libusb_device_id) {
                                case LIBUSB_SONY_RC_S380:
                                    ob_set_s(o, L"slotName", "Sony FeliCa RC-S380");
                                    break;
                                case LIBUSB_SONY_RC_S310:
                                    ob_set_s(o, L"slotName", "Sony FeliCa RC-S310");
                                    break;
                                case LIBUSB_SONY_RC_S320:
                                    ob_set_s(o, L"slotName", "Sony FeliCa RC-S320");
                                    break;
                                case LIBUSB_SONY_RC_S330:
                                    ob_set_s(o, L"slotName", "Sony FeliCa RC-S330");
                                    break;
                                default:
                                    break;
                            }
                            PA_Variable v = PA_CreateVariable(eVK_Object);
                            PA_SetObjectVariable(&v, o);
                            PA_SetCollectionElement(readers, PA_GetCollectionLength(readers), v);
                            success = true;
                        }
                    }
                }
            }
            libusb_free_device_list(devs, 1);
        }
        libusb_exit(NULL);
    }
#endif
    
    ob_set_b(status, L"success", success);
    ob_set_c(status, L"readers", readers);
    PA_ReturnObject(params, status);
}

static void SCARD_Read_tag(PA_PluginParameters params) {

	PA_ObjectRef status = PA_CreateObject();
	PA_ObjectRef args = PA_GetObjectParameter(params, 1);

	std::string slotName;

	char nfc_type = 'F';
	unsigned int timeout = 60;
	bool get_system = false;

	if (args) {
		CUTF8String stringValue;
		if (ob_get_s(args, L"slotName", &stringValue)) {
			slotName = (const char *)stringValue.c_str();
		}
		if (ob_get_s(args, L"card", &stringValue)) {
			if (stringValue == (const uint8_t *)"FeliCa") {
				nfc_type = 'F';
			}
			if (stringValue == (const uint8_t *)"TypeB") {
				nfc_type = 'B';
			}
			if (stringValue == (const uint8_t *)"TypeA") {
				nfc_type = 'A';
			}
		}
		if (ob_is_defined(args, L"timeout")) {
			int _timeout = ob_get_n(args, L"timeout");
			if (_timeout > 0) {
				timeout = _timeout;
			}
		}
		get_system = ob_get_b(args, L"system");
	}

    std::string uuid;
    generateUuid(uuid);
    
    /*
     
     default params
     
     */
    
    Json::Value threadCtx(Json::objectValue);
    
    threadCtx["complete"] = false;
    threadCtx["success"] = false;
    threadCtx["errorMessage"] = "";
    threadCtx["slotName"] = "";
    threadCtx["protocol"] = "";
    threadCtx["IDm"] = "";
    threadCtx["PMm"] = "";
    threadCtx["nfc_type"] = nfc_type;//for libusb
    threadCtx["timeout"] = timeout;
    threadCtx["get_system"] = get_system;//for libpafe
    
    if(1) {
        std::lock_guard<std::mutex> lock(scardMutex);
        scardStorage[uuid] = threadCtx;
    }
    
    auto func = [](std::string uuid, std::string slotName) {
                
        char nfc_type = 'F';
        unsigned int timeout = 60;
        bool get_system = false;
        
        if(1) {
            std::lock_guard<std::mutex> lock(scardMutex);
            Json::Value threadCtx = scardStorage[uuid];
            if(threadCtx.isObject()) {
                nfc_type = threadCtx["nfc_type"].asInt();
                timeout = threadCtx["timeout"].asInt();
                get_system = threadCtx["get_system"].asBool();
            }
        }
        
		bool is_pasori_s380 = false;

		if ((slotName == "Sony FeliCa Port/PaSoRi 3.0 0")
			|| (slotName == "Sony FeliCa RC-S380")
			|| (slotName == "Sony RC-S380/P")
			|| (slotName == "Sony RC-S380/S")
			) {
			is_pasori_s380 = true;
		}

        std::string errorMessage;
        
#if VERSIONMAC

        __block bool success = false;
        __block std::string IDm;
        __block std::string PMm;
        __block std::string nfcid;
        __block std::string appdata;
        __block std::string pinfo;
        __block std::string cid;
        __block std::string serviceDataJson;
        
        std::vector<uint8_t>usbbuf(LIBUSB_DATASIZE);
        
        int libusb_device_id = 0;
        
        if(slotName == "Sony FeliCa RC-S380"){
            libusb_device_id = LIBUSB_SONY_RC_S380;
        }else if(   (slotName == "Sony FeliCa RC-S310")
                 || (slotName == "Sony FeliCa RC-S320")
                 || (slotName == "Sony FeliCa RC-S330")){
            libusb_device_id = LIBUSB_SONY_RC_S330;
        }
        
        if(libusb_device_id != 0) {
            
            /* libpafe */
            pasori *p = NULL;
            felica *f = NULL;
            
            /* libusb */
            libusb_device_handle *device = NULL;
            usb_device_info devinfo;
            usb_device_info *devinfop = &devinfo;
            std::vector<uint8_t> *usbbufp = &usbbuf;
            Json::Value serviceData(Json::objectValue);
            
            bool isPolling = false;
            
            switch (libusb_device_id) {
                case LIBUSB_SONY_RC_S330:
                    p = pasori_open();
                    if(p) {
                        if(!pasori_init(p)) {
                            pasori_set_timeout(p, LIBUSB_API_TIMEOUT);
                            pasori_reset(p);
                            isPolling = true;
                        }
                    }
                    break;
                case LIBUSB_SONY_RC_S380:
                    int libusb_result = libusb_init(NULL);
                    if(libusb_result >= 0) {
                        device = libusb_open_device_with_vid_pid(NULL, LIBUSB_SONY, libusb_device_id);
                        if(device) {
                            // usb interface setting
                            libusb_set_auto_detach_kernel_driver(device, 1);
                            libusb_set_configuration(device, 1);
                            libusb_claim_interface(device, 0);
                            libusb_set_interface_alt_setting(device, 0, 0);
                            // get usb information
                            if(get_usb_information(device, devinfop)) {
                                packet_init(devinfop, LIBUSB_API_TIMEOUT);
                                packet_setcommandtype(devinfop, usbbufp, LIBUSB_API_TIMEOUT);
                                packet_switch_rf(devinfop, usbbufp, LIBUSB_API_TIMEOUT);
                                packet_inset_rf(devinfop, nfc_type, usbbufp, LIBUSB_API_TIMEOUT);
                                packet_inset_protocol_1(devinfop, usbbufp, LIBUSB_API_TIMEOUT);
                                packet_inset_protocol_2(devinfop, nfc_type,  usbbufp, LIBUSB_API_TIMEOUT);
                                isPolling = true;
                            }
                        }
                    }
                    break;
            }
                   
            if(isPolling) {
                
                time_t startTime = time(0);
                time_t anchorTime = startTime;

                uint8_t idm[8], pmm[8];
                
                while (isPolling) {
                    
                    time_t now = time(0);
                    time_t elapsedTime = abs(startTime - now);
                    elapsedTime = abs(anchorTime - now);

                    if(elapsedTime < timeout) {
                        size_t len = 0L;
                        switch (libusb_device_id) {
                            case LIBUSB_SONY_RC_S330:
                                if(p){
                                    f = felica_polling(p, FELICA_POLLING_ANY, 0, 0);
                                    if(!f) {
                                        isPolling = false;
                                    }else{
                                        
                                        print_hex(f->IDm, 8, IDm);
                                        print_hex(f->PMm, 8, PMm);
                                        success = true;
                                        isPolling = false;
                                        
                                        if(get_system) {
                                                 
                                            /* 090f */
                                            
                                            Json::Value service(Json::objectValue);

                                            service["code"] = "090f";
                                            Json::Value data(Json::arrayValue);

                                            felica *ff = NULL;
                                            uint16 resp[256];
                                            int n  = sizeof(resp)/sizeof(*resp);
                                            int r = felica_request_system(f, &n, resp);
                                            
                                            /*
                                             
                                             https://www.sony.co.jp/Products/felica/business/tech-support/?j-short=tech-support#FeliCa02
                                             https://ja.osdn.net/projects/felicalib/wiki/suica
                                             
                                             Request System Code コマンドを送信する。FeliCaのもつシステムコードのリストを得る。
                                             https://ja.osdn.net/users/bhbops/pf/libpafe_lite/wiki/FrontPage
                                             
                                             */
                                            
                                            if (!r){
                                                for (int i = 0; i < n; ++i) {
                                                    
                                                    /*
                                                     00FE :フェリカネットワークス社が管理する共通領域を示すシステムコード
                                                     0003 :交通系
                                                     802B :交通系（せたまるとIruCa）
                                                     */
                                                    
                                                    if ((resp[i] == 0x0003) || (resp[i] == 0x80de)) {
                                                        
                                                        uint16 systemCode = resp[i];
                                                        ff = felica_polling(f->p, systemCode, 0, 0);
                                                        if (ff == NULL) {
                                                            break;
                                                        }
                                                        
                                                        uint8_t b[2];
                                                        b[0] = systemCode >> 8;
                                                        b[1] = systemCode & 0x00FF;
                                                        
                                                        r = felica_search_service(ff);
                                                        
                                                        /*
                                                         
                                                         0xffffがサービスコードとして返却されるまで Search Service Code コマンドを送信する。
                                                         
                                                         */
                                                        
                                                        if(!r){
                                                            for (int j = 0; j < ff->service_num; ++j) {
                                                                uint16 serviceCode = ff->service[j].bin;
                                                                if(serviceCode == 0x090f) {
                                                                    service["code"] = "090f";
                                                                    if (ff->service[j].attr & 1) {
                                                                        int k = 0;
                                                                        uint8_t b[16];
                                                                        while (!felica_read_single(ff, ff->service[j].bin, 0, k, b)) {
                                                                            std::string hex;
                                                                            print_hex(b, 16, hex);
                                                                            data.append(hex);
                                                                            service["data"] = hex;
                                                                            k++;
                                                                        }
                                                                    }
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        
                                                        free(ff);
                                                        
                                                        break;
                                                    }
                                                }
                                            }
                                                    
                                            service["data"] = data;

                                            Json::StreamWriterBuilder writer;
                                            writer["indentation"] = "";
                                            serviceDataJson = Json::writeString(writer, service);
    
                                        }
                                                
                                    }
                                }
                                break;
                                
                            case LIBUSB_SONY_RC_S380:
                                len = packet_sens_req(devinfop, nfc_type, usbbufp, LIBUSB_API_TIMEOUT_FOR_POLLING);
                                if(len >= 0) {
                                    if(usbbuf[9] == 0x05 && usbbuf[10] == 0x00) {
                                        int rlen = ((usbbuf[6] << 8) + usbbuf[5]);
                                        if(rlen == 27) {
                                            if(usbbuf[6 + 9] == 0x14 && usbbuf[7 + 9] == 0x01) {
                                                memcpy(idm, &usbbuf[ 8 + 9], 8);
                                                memcpy(pmm, &usbbuf[16 + 9], 8);
                                                print_hex(idm, 8, IDm);
                                                print_hex(pmm, 8, PMm);
                                                success = true;
                                                isPolling = false;
                                            }
                                        }
                                        if(isPolling) {
                                            /* ATQB (response to REQB ) */
                                            if(usbbuf[6 + 9] == 0x50) /* response code */ {
                                                
                                                uint8_t _nfcid[4], _appdata[4], _pinfo[3], _cid[1];
                                                
                                                memcpy(  _nfcid, &usbbuf[ 7 + 9], 4);/* PUPI */
                                                memcpy(_appdata, &usbbuf[11 + 9], 4);/* Application Data */
                                                memcpy(  _pinfo, &usbbuf[15 + 9], 3);/* Protocol Info */
                                                memcpy(    _cid, &usbbuf[18 + 9], 1);/* CID */
                                                
                                                print_hex(_nfcid,   4, nfcid);
                                                print_hex(_appdata, 4, appdata);
                                                print_hex(_pinfo,   3, pinfo);
                                                print_hex(_cid,     1, cid);
                                                
                                                success = true;
                                                isPolling = false;
                                                
                                            }
                                        }
                                        
                                        if(isPolling) {
                                               /* ATQA incomplete: need to implement SAK anti-collision sequence
                                                http://www.ti.com/lit/an/sloa136/sloa136.pdf
                                                https://www.nxp.com/docs/en/application-note/AN10833.pdf
                                                https://github.com/nfc-tools/libnfc/blob/master/examples/nfc-anticol.c
                                                */
                                        }
                                    }
                                }else{
                                    /* read/write error */
                                    usleep(LIBUSB_USLEEP_DURATION);
                                }
                                break;
                        }
                    }else{
                        /* timeout */
                        isPolling = false;
                    }
                }
             
                switch (libusb_device_id) {
                    case LIBUSB_SONY_RC_S330:
                        if(f) {
                            free(f);
                        }
                        if(p) {
                            pasori_close(p);
                        }
                        break;
                    case LIBUSB_SONY_RC_S380:
                        if(success) {
                           
                            if (get_system) {
                             
                                /* 090f */
                                                                
                                uint8_t cmd[21] = {
                                    
                                    0x04,
                                    0x86,
                                    0x01,
                                    
                                    0x12,       /* cmd len */
                                    
                                    0x06,       /* cmd_code:0x06 (read_without_encryption) */
                                    idm[0],     /* captured tag identifier (IDm) */
                                    idm[1],
                                    idm[2],
                                    idm[3],
                                    idm[4],
                                    idm[5],
                                    idm[6],
                                    idm[7],
                                    0x01, /* count of sc */
                                    0x0f,
                                    0x09,
                                    0x02, /* count of bc */
                                    
                                    0x80, //0x11
                                    0x00,
                                    
                                    0x80, //0x12
                                    0x01
                                };
                                                                
                                packet_inset_rf(devinfop, nfc_type, usbbufp, LIBUSB_API_TIMEOUT);
                                packet_inset_protocol_1(devinfop, usbbufp, LIBUSB_API_TIMEOUT);
                                
                                Json::Value service(Json::objectValue);

                                service["code"] = "090f";
                                Json::Value data(Json::arrayValue);
                                        
                                size_t len;
                                uint8_t bd[16];
                                std::string hex;
                                
//                                for (int i = 0; i < 10; ++i) {
                                    
                                    packet_write(devinfop, cmd, sizeof(cmd), usbbufp, timeout);//InCommRF
                                    
                                    isPolling = true;
                                    time_t startTime = time(0);
                                    time_t anchorTime = startTime;
                                    while (isPolling) {
                                        time_t now = time(0);
                                        time_t elapsedTime = abs(startTime - now);
                                        elapsedTime = abs(anchorTime - now);
                                        
                                        if(elapsedTime < timeout) {
                                            len = packet_sens_req(devinfop, nfc_type, usbbufp, LIBUSB_API_TIMEOUT_FOR_POLLING);
                                            if(len >= 0) {
                                                if(usbbuf[9] == 0x05 && usbbuf[10] == 0x00) {
                                                    int rlen = ((usbbuf[6] << 8) + usbbuf[5]);
                                                    switch (rlen) {
                                                        case 52:
                                                            
                                                            memcpy(bd, &usbbuf[28], 16);
                                                            print_hex(bd, 16, hex);
                                                            data.append(hex);
                                                            
                                                            memcpy(bd, &usbbuf[28+16], 16);
                                                            print_hex(bd, 16, hex);
                                                            data.append(hex);
                                                            
                                                            cmd[18] = cmd[18] + 2;
                                                            cmd[20] = cmd[20] + 2;

                                                            break;
                                                        default:
                                                            break;
                                                    }
                                                    
//                                                    NSLog(@"rlen:%d, cmd[20]:%d",rlen, cmd[20]);
                                                    
                                                    if(cmd[20] == 19){
                                                        isPolling = false;
                                                    }else{
                                                        packet_write(devinfop, cmd, sizeof(cmd), usbbufp, timeout);//InCommRF
                                                    }
                                                }
                                            }
                                        }else{
                                            /* timeout */
                                            isPolling = false;
                                        }
                                    }

//                                }

                                service["data"] = data;

                                Json::StreamWriterBuilder writer;
                                writer["indentation"] = "";
                                serviceDataJson = Json::writeString(writer, service);
                            }
   
                        }
                        // close
                        libusb_release_interface(device, 0);
                        libusb_close(device);
                        libusb_exit(NULL);
                        break;
                }
            }
        }else
        {
            TKSmartCardSlotManager *manager = [TKSmartCardSlotManager defaultManager];
            if(manager) {
                NSString *name = [[NSString alloc]initWithUTF8String:slotName.c_str()];
                TKSmartCardSlot *slot = [manager slotNamed:name];
                [name release];
                if(slot) {
                    TKSmartCard *smartCard = [slot makeSmartCard];
                    if(smartCard) {
                        dispatch_semaphore_t sem = dispatch_semaphore_create(0);
                        [smartCard beginSessionWithReply:^(BOOL _success, NSError *error) {
                            
                            if (_success) {

                                uint8_t pbSendBuffer_GetIDm[5] = {
                                    APDU_CLA_GENERIC,
                                    APDU_INS_GET_DATA,
                                    APDU_P1_GET_UID,
                                    APDU_P2_NONE,
                                    APDU_LE_MAX_LENGTH
                                };
                               
                                [smartCard
                                 transmitRequest:[NSData dataWithBytes:pbSendBuffer_GetIDm
                                                                length:sizeof pbSendBuffer_GetIDm]
                                                                 reply:^(NSData *response, NSError *error) {
                                    
                                    if (error == nil)
                                    {
                                        uint8_t SW1 = 0;
                                        uint8_t SW2 = 0;
                                        [response getBytes:&SW1 range:NSMakeRange([response length] - 2, 1)];
                                        [response getBytes:&SW2 range:NSMakeRange([response length] - 1, 1)];
                                        if ( SW1 != 0x90 || SW2 != 0x00 )
                                        {
                                            if ( SW1 == 0x63 && SW2 == 0x00 )
                                            {
                                                /* data is not available */
                                            }
                                        }
                                        else
                                        {
                                            print_hex((const uint8_t *)[response bytes], 8, IDm);
                                            success = true;
                                        }
                                        
                                        uint8_t pbSendBuffer_GetPMm[5] = {
                                            APDU_CLA_GENERIC,
                                            APDU_INS_GET_DATA,
                                            APDU_P1_GET_PMm,
                                            APDU_P2_NONE,
                                            APDU_LE_MAX_LENGTH
                                        };
                                        
                                        [smartCard
                                         transmitRequest:[NSData dataWithBytes:pbSendBuffer_GetPMm
                                                                        length:sizeof pbSendBuffer_GetPMm]
                                                                         reply:^(NSData *response, NSError *error) {
                                            
                                            if (error == nil)
                                            {
                                                uint8_t SW1 = 0;
                                                uint8_t SW2 = 0;
                                                [response getBytes:&SW1 range:NSMakeRange([response length] - 2, 1)];
                                                [response getBytes:&SW2 range:NSMakeRange([response length] - 1, 1)];
                                                if ( SW1 != 0x90 || SW2 != 0x00 )
                                                {
                                                    if ( SW1 == 0x63 && SW2 == 0x00 )
                                                    {
                                                        /* data is not available */
                                                    }
                                                }
                                                else
                                                {
                                                    print_hex((const uint8_t *)[response bytes], 8, PMm);
                                                    success = true;
                                                }
                                                
                                                if (get_system) {

                                                        /* 090f */
                                                    
                                                    __block Json::Value service(Json::objectValue);

                                                    service["code"] = "090f";
                                                    __block Json::Value data(Json::arrayValue);
                                                    
                                                    smartCard.cla = 0xFF;
                                                                                                        
                                                    uint8_t pbSendBuffer_SelectFile[7] = {
                                                        APDU_CLA_GENERIC,
                                                        APDU_INS_SELECT_FILE, /* SelectFile */
                                                        0x00, /* P1 */
                                                        0x01, /* P2 */
                                                        0x0f,//0x02,
                                                        0x09,//0x0f, /* service Hi */
                                                        0x00//0x09 /* service Lo */
                                                    };
                                                    
                                                    __block int cnt = 0;
                                                    
                                                    for (int i = 0; i < 20; ++i) {
                                                                                                                
                                                        [smartCard
                                                         transmitRequest:[NSData dataWithBytes:pbSendBuffer_SelectFile
                                                                                        length:sizeof(pbSendBuffer_SelectFile)]
                                                         reply:^(NSData *response, NSError *error) {
                                                            
                                                            if (error == nil)
                                                            {
                                                                uint8_t pbSendBuffer_ReadBinary[5] = {
                                                                    0xff,
                                                                    0xb0, /*ReadBinary */
                                                                    0x00,
                                                                    0x00, /* block */
                                                                    0x00
                                                                };
                                                                
                                                                pbSendBuffer_ReadBinary[3] = i;
                                                                
                                                                [smartCard
                                                                 transmitRequest:[NSData dataWithBytes:pbSendBuffer_ReadBinary
                                                                                                length:sizeof(pbSendBuffer_ReadBinary)]
                                                                 reply:^(NSData *response, NSError *error) {
                                                                    
                                                                    
                                                                    if (error == nil)
                                                                    {
                                                                        std::string hex;
                                                                        print_hex((const uint8_t *)[response bytes], 16, hex);
                                                                        data.append(hex);
                                                                    }
                                                                    
                                                                    cnt++;
                                                                    
                                                                    if(cnt == 19){
                                                                        [smartCard endSession];
                                                                        
                                                                        service["data"] = data;
                                                                        
                                                                        Json::StreamWriterBuilder writer;
                                                                        writer["indentation"] = "";
                                                                        serviceDataJson = Json::writeString(writer, service);
                                                                        
                                                                        dispatch_semaphore_signal(sem);
                                                                    }
          
                                                                }];
                                                                usleep(TK_USLEEP_DURATION);
                                                            }
                                                            
                                                        }];
                                                        usleep(TK_USLEEP_DURATION);
                                                    }

                                                }else{
                                                    //!get_system
                                                    [smartCard endSession];
                                                    dispatch_semaphore_signal(sem);
                                                }
                                            }else{
                                                //transmitRequest(pbSendBuffer_GetPMm)failed
                                                [smartCard endSession];
                                                dispatch_semaphore_signal(sem);
                                            }
                                        }];
                                    }else{
                                        //transmitRequest(pbSendBuffer_GetIDm)failed
                                        [smartCard endSession];
                                        dispatch_semaphore_signal(sem);
                                    }
                                }];

                            }else{
                               //beginSessionWithReply() failed
                                dispatch_semaphore_signal(sem);
                            }
                            
                        }];
                        // wait for the asynchronous blocks to finish
                        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
                    }else{
                        errorMessage = "TKSmartCard::makeSmartCard() failed";
                    }
                }else{
                    errorMessage = "TKSmartCardSlotManager::slotNamed() failed";
                }
            }else{
                errorMessage = "TKSmartCardSlotManager::defaultManager() failed";
            }
  
        }
#else
     /*
      
      windows
      
      */

        std::string serviceDataJson;
        
		std::string IDm;
		std::string PMm;

		bool success = false;

        LPTSTR lpszReaderName = NULL;
        CUTF16String name;
        DWORD protocols = SCARD_PROTOCOL_T0|SCARD_PROTOCOL_T1;
        DWORD mode = SCARD_SHARE_SHARED;
        DWORD scope = SCARD_SCOPE_USER;
        /*
         
         TODO: options - set protocol, mode, scope
         
         */
        u8_to_u16(slotName, name);
        lpszReaderName = (LPTSTR)name.c_str();
        if(name.length()) {
            SCARDCONTEXT hContext;
            LONG lResult = SCardEstablishContext(scope, NULL, NULL, &hContext);
            /* http://eternalwindows.jp/security/scard/scard02.html */
			if (lResult == SCARD_E_NO_SERVICE) {
				HANDLE hEvent = SCardAccessStartedEvent();
				DWORD dwResult = WaitForSingleObject(hEvent, DEFAULT_TIMEOUT_MS_FOR_RESOURCE_MANAGER);
				if (dwResult == WAIT_OBJECT_0) {
					lResult = SCardEstablishContext(scope, NULL, NULL, &hContext);
				}
				SCardReleaseStartedEvent();
			}

                if (lResult == SCARD_S_SUCCESS) {
                    SCARD_READERSTATE readerState;
                    readerState.szReader = lpszReaderName;
                    readerState.dwCurrentState = SCARD_STATE_UNAWARE;
                    /* return immediately; check state */
                    lResult = SCardGetStatusChange(hContext, 0, &readerState, 1);
                    if (lResult == SCARD_S_SUCCESS) {
                    
                        int is_card_present = 0;
                        
                        time_t startTime = time(0);
                        time_t anchorTime = startTime;
                        
                        bool isPolling = true;

                        while (isPolling) {
                            
                            time_t now = time(0);
                            time_t elapsedTime = abs(startTime - now);
                            
                            if(elapsedTime > 0)
                            {
                                startTime = now;
                            }
                            
                            elapsedTime = abs(anchorTime - now);
                            
                            if(elapsedTime < timeout) {

                                if (readerState.dwEventState & SCARD_STATE_EMPTY) {
                                    lResult = SCardGetStatusChange(hContext, LIBPCSC_API_TIMEOUT, &readerState, 1);
                                }
                                
                                if (readerState.dwEventState & SCARD_STATE_UNAVAILABLE) {
                                    isPolling = false;
                                }
                                
                                if (readerState.dwEventState & SCARD_STATE_PRESENT) {
                                    is_card_present = 1;
                                    isPolling = false;
                                }
                                 
                            }else{
                                /* timeout */
                                isPolling = false;
                            }
                               
                        }
                        
                        if(is_card_present) {
                     
                            SCARDHANDLE hCard;
                            DWORD dwActiveProtocol;
                            DWORD dwProtocol;
                            DWORD dwAtrSize;
                            DWORD dwState;
                            
                            BYTE atr[256];
                            
                            lResult = SCardConnect(hContext,
                                                   lpszReaderName,
                                                   mode,
                                                   protocols,
                                                   &hCard,
                                                   &dwActiveProtocol);
                            switch (lResult)
                            {
                                case (LONG)SCARD_W_REMOVED_CARD:
                                    /* SCARD_W_REMOVED_CARD */
                                    break;
                                case SCARD_S_SUCCESS:
                                    lResult = SCardStatus(hCard, NULL, NULL, &dwState, &dwProtocol, atr, &dwAtrSize);
                                    if (lResult == SCARD_S_SUCCESS) {
                                        
                                        BYTE pbSendBuffer_GetIDm[5] = {
                                            APDU_CLA_GENERIC,
                                            APDU_INS_GET_DATA,
                                            APDU_P1_GET_UID,
                                            APDU_P2_NONE,
                                            APDU_LE_MAX_LENGTH
                                        };
                                        
                                        BYTE pbSendBuffer_GetPMm[5] = {
                                            APDU_CLA_GENERIC,
                                            APDU_INS_GET_DATA,
                                            APDU_P1_GET_PMm,
                                            APDU_P2_NONE,
                                            APDU_LE_MAX_LENGTH
                                        };

										BYTE pbSendBuffer_SelectFile[7] = {
											0xff,
											0xA4, /* SelectFile */
											0x00, /* P1 */
											0x01, /* P2 */
											0x0f, /* service Hi */
											0x09, /* service Lo */
											0x00  
										};

										BYTE pbSendBuffer_ReadBinary[5] = {
											0xff,
											0xb0, /*ReadBinary */
											0x00,
											0x00, /* block */
											0x00
										};

										if (is_pasori_s380) {
											pbSendBuffer_SelectFile[4] = 0x02;
											pbSendBuffer_SelectFile[5] = 0x0f;
											pbSendBuffer_SelectFile[6] = 0x09;
										}

                                        BYTE pbRecvBuffer[2048];
                                        DWORD cbRecvLength;
                                        BYTE SW1 = 0;
                                        BYTE SW2 = 0;

										cbRecvLength = 2048;
                                        lResult = SCardTransmit(hCard,
                                                                SCARD_PCI_T1,
                                                                pbSendBuffer_GetIDm,
                                                                sizeof(pbSendBuffer_GetIDm),
                                                                NULL,
                                                                pbRecvBuffer,
                                                                &cbRecvLength);
                                        switch(lResult)
                                        {
                                            case SCARD_S_SUCCESS:
                                                SW1 = pbRecvBuffer[cbRecvLength - 2];
                                                SW2 = pbRecvBuffer[cbRecvLength - 1];
                                                if ( SW1 != 0x90 || SW2 != 0x00 )
                                                {
                                                    if ( SW1 == 0x63 && SW2 == 0x00 )
                                                    {
                                                        /* data is not available */
                                                    }
                                                }
                                                else
                                                {
													print_hex(pbRecvBuffer, 8, IDm);
													success = true;
                                                }
                                                break;
                                            case 0x458:
                                                lResult = SCARD_W_REMOVED_CARD;
                                                break;
                                            case 0x16:
                                                lResult = SCARD_E_INVALID_PARAMETER;
                                                break;
                                            default:
                                                break;
                                        }
                                        
										cbRecvLength = 2048;
										lResult = SCardTransmit(hCard,
                                                                SCARD_PCI_T1,
                                                                pbSendBuffer_GetPMm,
                                                                sizeof(pbSendBuffer_GetPMm),
                                                                NULL,
                                                                pbRecvBuffer,
                                                                &cbRecvLength);
                                        switch(lResult)
                                        {
                                            case SCARD_S_SUCCESS:
                                                SW1 = pbRecvBuffer[cbRecvLength - 2];
                                                SW2 = pbRecvBuffer[cbRecvLength - 1];
                                                if ( SW1 != 0x90 || SW2 != 0x00 )
                                                {
                                                    if ( SW1 == 0x63 && SW2 == 0x00 )
                                                    {
                                                        /* data is not available */
                                                    }
                                                }
                                                else
                                                {
													print_hex(pbRecvBuffer, 8, PMm);
													success = true;
                                                }
                                                break;
                                            case 0x458:
                                                lResult = SCARD_W_REMOVED_CARD;
                                                break;
                                            case 0x16:
                                                lResult = SCARD_E_INVALID_PARAMETER;
                                                break;
                                            default:
                                                break;
                                        }
                                   
										if (get_system) {

												/* 090f */

												Json::Value service(Json::objectValue);

												service["code"] = "090f";
												Json::Value data(Json::arrayValue);

												for (int i = 0; i < 20; ++i) {

													pbSendBuffer_ReadBinary[3] = i;

													cbRecvLength = 2048;
													lResult = SCardTransmit(hCard,
														SCARD_PCI_T1,
														pbSendBuffer_SelectFile,
														sizeof(pbSendBuffer_SelectFile),
														NULL,
														pbRecvBuffer,
														&cbRecvLength);

													if (lResult == SCARD_S_SUCCESS) {
														cbRecvLength = 2048;

														SCARD_IO_REQUEST pci;
														pci.cbPciLength = cbRecvLength;

														lResult = SCardTransmit(hCard,
															SCARD_PCI_T1,
															pbSendBuffer_ReadBinary,
															sizeof(pbSendBuffer_ReadBinary),
															&pci,
															pbRecvBuffer,
															&cbRecvLength);

														if (lResult == SCARD_S_SUCCESS) {
															std::string hex;
															print_hex(pbRecvBuffer, 16, hex);
															data.append(hex);
															service["data"] = hex;
														}
														else {
															break;
														}
													}
												}

												service["data"] = data;

												Json::StreamWriterBuilder writer;
												writer["indentation"] = "";
												serviceDataJson = Json::writeString(writer, service);
										}
									
									}/* SCardStatus */
                                    SCardDisconnect(hCard, SCARD_LEAVE_CARD);
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                    SCardReleaseContext(hContext);
                }
        }
#endif

        if(1) {
            std::lock_guard<std::mutex> lock(scardMutex);
            if(scardStorage[uuid].isObject()) {
                scardStorage[uuid]["IDm"] = IDm;
                scardStorage[uuid]["PMm"] = PMm;
                scardStorage[uuid]["errorMessage"] = errorMessage;
                scardStorage[uuid]["slotName"] = slotName;
                scardStorage[uuid]["success"] = success;
                scardStorage[uuid]["complete"] = true;
                scardStorage[uuid]["serviceDataJson"] = serviceDataJson;
            }
        }
    };
    
    scardTasks.insert(std::map< std::string,
                      std::future<void> >::value_type(uuid,
                                                      std::async(std::launch::async,
                                                                 func,
                                                                 uuid,
                                                                 slotName)));
    
#if VERSIONMAC
    if(!checkAccess(status)) {
        ob_set_s(status, L"warning", "com.apple.security.smartcard is missing in app entitlement");
    }
#endif
    
    ob_set_s(status, L"uuid", uuid.c_str());
    PA_ReturnObject(params, status);
}

static void SCARD_Get_status(PA_PluginParameters params) {
 
    PA_ObjectRef status = PA_CreateObject();
    
    PA_Unistring *ustr = PA_GetStringParameter(params, 1);
    CUTF16String u16 = CUTF16String(ustr->fString, ustr->fLength);

    std::string uuid;
    u16_to_u8(u16, uuid);
    
    bool complete = false;
    bool success = false;
    std::string slotName, errorMessage, IDm, PMm, nfcid, appdata, pinfo, cid, serviceDataJson;
    
    Json::Value threadCtx = scardStorage[uuid];
    if(threadCtx.isObject()) {
        std::lock_guard<std::mutex> lock(scardMutex);
        success = threadCtx["success"].asBool();
        complete = threadCtx["complete"].asBool();
        slotName = threadCtx["slotName"].asString();
        errorMessage = threadCtx["errorMessage"].asString();
        IDm = threadCtx["IDm"].asString();
        PMm = threadCtx["PMm"].asString();
        nfcid = threadCtx["nfcid"].asString();
        appdata = threadCtx["appdata"].asString();
        pinfo = threadCtx["pinfo"].asString();
        cid = threadCtx["cid"].asString();
        serviceDataJson = threadCtx["serviceDataJson"].asString();
    }
    
    ob_set_s(status, L"uuid", uuid.c_str());
    ob_set_b(status, L"success", success);
    ob_set_b(status, L"complete", complete);
    ob_set_s(status, L"slotName", slotName.c_str());

    if(errorMessage.length() != 0) {
        ob_set_s(status, L"errorMessage", errorMessage.c_str());
    }
    
    if(serviceDataJson.length() != 0) {
        
        CUTF16String jsonString;
        u8_to_u16(serviceDataJson, jsonString);
        
//        ob_set_s(status, L"serviceDataJson", serviceDataJson.c_str());
        
        PA_ulong32 version = PA_Get4DVersion() & 0x0000FFFF;
        PA_Variable params[2], result;
        PA_ObjectRef object = NULL;
        PA_Unistring string;
        
        string = PA_CreateUnistring((PA_Unichar *)jsonString.c_str());
        PA_SetStringVariable( &params[0], &string );
        PA_SetLongintVariable( &params[1], eVK_Object );
        result = PA_ExecuteCommandByID( 1218, params, 2 );    // JSON Parse
        object = PA_GetObjectVariable( result );
        PA_DisposeUnistring( &string );
        
        ob_set_o(status, L"serviceData", object);
    }
    
    if(IDm.length() != 0) {
        ob_set_s(status, L"IDm", IDm.c_str());
    }
    
    if(PMm.length() != 0) {
        ob_set_s(status, L"PMm", PMm.c_str());
    }
    
    if(nfcid.length() != 0) {
        ob_set_s(status, L"nfcid", nfcid.c_str());
    }
    
    if(appdata.length() != 0) {
        ob_set_s(status, L"appdata", appdata.c_str());
    }
    
    if(cid.length() != 0) {
        ob_set_s(status, L"cid", cid.c_str());
    }
    
    if(pinfo.length() != 0) {
        ob_set_s(status, L"pinfo", pinfo.c_str());
    }
        
    PA_ReturnObject(params, status);
    
    if(complete) {
        scard_clear(uuid);
    }
}

#pragma mark -

static short checksum(char cmd, uint8_t *buf, int size) {
    
  int sum = (unsigned int)cmd;
  for(int i = 0; i < size; i++){
    sum += buf[i];
  }
  return (0x100 - sum) % 0x100;
}

#if VERSIONMAC
static bool checkAccess(PA_ObjectRef status) {
        
    bool entitlement = false;
    
    /*
     
     https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_smartcard
     
     */
    
    SecTaskRef sec = SecTaskCreateFromSelf(kCFAllocatorMalloc);
    CFErrorRef err = nil;
    CFBooleanRef boolValue = (CFBooleanRef)SecTaskCopyValueForEntitlement(sec,
                                                                          CFSTR("com.apple.security.smartcard"),
                                                                          &err);
    if(!err) {
        if(boolValue) {
            entitlement = CFBooleanGetValue(boolValue);
        }
    }
    
    CFRelease(sec);
        
    return entitlement;
}
#endif

#pragma mark -

static void u16_to_u8(CUTF16String& u16, std::string& u8) {
    
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            u8 = std::string((const char *)&buf[0]);
        }
    }else{
        u8 = std::string((const char *)"");
    }

#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)u16.c_str(), u16.length());
    if(str){
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        u8 = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

static void u8_to_u16(std::string& u8, CUTF16String& u16) {
    
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), (LPWSTR)&buf[0], len)){
            u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        u16 = CUTF16String((const PA_Unichar *)L"");
    }
    
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)u8.c_str(), u8.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}

/*
 
 https://qiita.com/YasuakiNakazawa/items/3109df682af2a7032f8d
 
 */
